`````{admonition} Scripts for **Step 3 - Self-calibration of the continuum**:
:class: tip
- <a href="https://github.com/jjspeedie/workflow.2021.1.0690.S/blob/main/step3_continuum_selfcal.py" target="_blank">step3_continuum_selfcal.py</a> # main script
- <a href="https://github.com/jjspeedie/workflow.2021.1.0690.S/blob/main/dictionary_data.py" target="_blank">dictionary_data.py</a> # loads data_dict
- <a href="https://github.com/jjspeedie/workflow.2021.1.0690.S/blob/main/selfcal_utils.py" target="_blank">selfcal_utils.py</a> # selfcal functions
`````

# Self-Calibration of Short-Baseline Execution Blocks

## Summary of path through self-calibration

````{card}
<center>

<img src="images/ABAur_SB_concat_shifted_cont_summary.jpg" alt="ABAur_SB_concat_shifted_cont_summary" class="mb-1" width="100%">

</center>
+++
(Note: Empty cells are not meaningless; they mean '', which in CASA either means 'all' or 'nothing'.)
````



### Explanation of parameter choices

Threshold: should be the same in every round to compare apples to apples...

**gaincal spw**: Selecting all spectral windows.

**gaincal solint**: The time interval on which to generate solutions. 'inf' goes as wide as the boundaries specified by the combine parameter. In the first and second round (p1, p2), 1 solution is found per scan. Later we get down to 18 seconds (3x the record interval). In the last round we find 1 solution per scan again. For reference, here's the number of seconds in each scan, in each execution block:

````{card}
<center>

<img src="images/number-seconds-in-each-scan.png" alt="number-seconds-in-each-scan" class="mb-1" width="100%">

</center>
+++
For the SB-only self-cal, the solints 243s, 120s, 60s, 30s, 18s roughly correspond to: half a scan, a quarter of a scan, an eighth of a scan, a sixteenth of a scan, and then 3x the record length (6s).
````

**gaincal combine**: Dimensions of the data to combine when generating solutions. In the first two rounds, we avoid combining spectral windows (i.e., we generate per-spw solutions) to account for any per-spw phase offsets. Later, we have to combine spectral windows because the SNR of the solutions (in the line spws) is too low.

**gaincal refant**: Chosen by me, using the refant lists generated by the pipeline hif_refant task, shown in the weblog. Happy coincidence (?) that the 3 highest ranked antennas in SB EB1 were the same as in SB EB2. If I was more comprehensive, I would've also specified the antenna's pad, in case any were moved between executions, but the weblog did not specify the pad.

**gaincal minSNR**: Minimum SNR of the solutions. If a solution has SNR below this threshold, then it (and the corresponding data) is flagged, and a statement is printed. For example: "3 of 41 solutions flagged due to SNR < 3 in spw=10 at 2022/07/17/14:31:53.5", and then later "7 of 36 solutions flagged due to SNR < 3 in spw=15 at 2022/07/19/12:12:23.5". Unfortunately there's no way to access/save those printouts, so I just copy and paste them from the terminal into a script and count them up later. These printouts are one of the factors you use to decide whether to use the generated solutions. If applycal applymode='calflag', then you lose that flagged data. To get a sense of what relative amount of data did not meet the minSNR, you would have to multiply [the total number of solution intervals found (depends on solint and number of scans)] x [the number of antennas] x [the number of spectral windows (depends on combine)].

**gaincal gaintype**: Could've used 'G', we only have 1 polarization mode, but DSHARP uses 'T'.

**gaincal calmode**: Sets 'phase' or 'amplitude + phase' self-cal. We attempt 1 round of amplitude+phase self-cal.

**gaincal scan**: Selecting all scans.

**gaincal spwmap**: I actually don't know what this does.

**gaincal num flagged solns**: See "gaincal minSNR".

**applycal spw**: Selecting all spectral windows.

**applycal applymode**: Leaving is as the default (''), which indicates 'calflag', meaning we apply the calibration and apply the flags.

**applycal interp**: The kind of interpolation to use between solutions. 'Linear' is the default. Linear 'PD' adds an additional term into the solve that accounts for the frequency-dependence if you have a large bandwidth. Ryan says in our case it's overkill ("like using GR equations when in Newtonian regime"), but DSHARP uses it and I figured it doesn't hurt.

**applycal spwmap**: Leave this as '' if combine does not include spw. If combine does include spw, then you need to tell applycal which spws of the calibration table to apply to which spws of the data.

`````{admonition} Mistake later realized...
:class: tip
In the last round of self calibration on the SB concatenated data (which is amplitude+phase), combine='' in gaincal, but spwmap=[0,0,0,0,0,5,5,5,5,5] in applycal. In other words, solutions were generated on a per-spw basis, but then the solution for spw 0 was applied to spw 0-4, and the solution for spw 5 was applied to spw 5-9. It was a leftover relic parameter set that way because I initially did try with combine='spw' in gaincal (8 flagged solutions), but then changed my mind (92 flagged solutions) in favour of the chance to account for per-spw amplitude offsets, if any. I realized this mistake only after continuum selfcal was all finished. This may have ramifications later on in the continuum self-cal of the combined (SB+LB) data. I won't make the same applycal mistake when applying the continuum self-cal solutions to the lines, but it is the case that the SB+LB solutions were generated using SB data where the wrong spwmap was applied. There aren't really systematic offsets in the solutions between spws though, if you look at the plots below. Also, to reduce the number of flagged solutions, the SB+LB amplitude+phase selfcal (see below) was done with combine='spw' anyway. These two things, combined with how long it would take me to redo it at this point, suggests to me it's not worth correcting.
`````

**tclean imsize**: Set to go out to the primary beam FWHM (~20 arcsec).

**tclean cellsize**: Set to sample the beam with ~10 cells.

**tclean specmode**: 'mfs' makes a continuum image.

**tclean deconvolver**: Ryan suggested hogbom (basis of delta functions) rather than multiscale (basis of Gaussians) for disks with rings.

**tclean weighting**: Briggs, of course.

**tclean spw**: Using all spws to create a continuum image (we want to include the line spws in the model generation).

**tclean robust**: Taken to be 0.5 for the SB self-cal, as DSHARP did, but we increase to 1.0 for the SB+LB self-cal.

**result rms (uJy/beam, mK)**: Measured rms noise in the continuum image. This decreases with each round. At the end of this self-cal, we improve by a factor of 2. (Note however that these images were not cleaned very deeply, nor are they primary beam corrected).

**result peak Inu (mJy/beam)**: Maximum intensity value in the image. This increases with each round, except between p6 and ap, where it decreases (to be expected).

**result disk flux (mJy)**: Total flux from the disk (measured within the clean mask). This increases with each round, except between p6 and ap, where it decreases (to be expected).

**result bmin/bmin (mas)**: The beam size increases with round, as we lose the flagged data (as expected). In total the beam axes both increase by about 30 mas.

**result SNR**: This increases with each round, including between p6 and ap. At the end of this self-cal, we improve by a factor greater than 2.


## Achieved phase solutions as a function of time and antenna (the calibration tables)

Both SB EB1 and SB EB2 were self-calibrated together, but the following plots the solutions separately (to be able to resolve the time axis).

### SB EB1

````{card}
<center>

<video width="100%" controls>
  <source src="../_static/videos/SB_concat_shifted_EB1_cal.mp4" type="video/mp4">
</video>

</center>
+++
caption
````

### SB EB2

````{card}
<center>

<video width="100%" controls>
  <source src="../_static/videos/SB_concat_shifted_EB2_cal.mp4" type="video/mp4">
</video>

</center>
+++
caption
````

## Images made after each round

Image achieved after each round, with a large colour bar stretch to exaggerate faint emission.

````{card}
<center>

<video width="85%" controls>
  <source src="../_static/videos/SB_concat_shifted_cont.mp4" type="video/mp4">
</video>

</center>
+++
caption
````

`````{admonition} Thoughts...
:class: tip
There is noise outside the disk in the NW-SE directions. It becomes slightly more uniform with each round of self-cal. It wasn't present in any of the deeply-cleaned per-execution block images.
`````

`````{admonition} Something to do differentlyâ€¦
:class: tip
Currently, we take a not-very-deeply-cleaned image as the initial or starting model for the self calibration ("SB concat shifted p0" in above movie). Perhaps a better starting model would be a more deeply cleaned image.
`````

```{note}
Jess might add here: Images of model and residuals
```

## The results, before and after

````{card}
<center>

<img src="images/SB-before-after.gif" alt="SB-before-after" class="mb-1" width="850%">

</center>
+++
caption
````


We achieve a decrease in rms noise by a factor of 2. The peak intensity increases by about 2 mJy/beam. The SNR improves by a factor of 2.2. The outer ring becomes more uniformly bright around its azimuth and more compact/well-defined. The inner cavity becomes more radially extended and appears emptier.

Notice how the beam got bigger - that's because we flagged some data.
